---
title: "Ausplots"
output:
  pdf_document:
  latex_engine: xelatex
vignette: >
  %\VignetteIndexEntry{ausplots}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
                                                  "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = !is_check,
  purl = !is_check,
  tidy.opts = list(width.cutoff = 80), 
  tidy = TRUE
)
rm(list = ls())

set.seed(1)
```

In this vignette, we explore show how to fit our point process model to the TERN Ausplots dataset.
We begin by installing the `ppjsdm` package which implements the saturated pairwise interaction Gibbs point process.
We also load the `rgdal` library for its coordinate systems implementation.

```{r setup}
need_ppjsdm <- !("ppjsdm" %in% installed.packages()[, "Package"])
if(need_ppjsdm) {
  library(devtools)
  devtools::install_github("iflint1/ppjsdm", 
                           upgrade = "never",
                           quiet = TRUE)
}

suppressMessages(library(ppjsdm))
suppressMessages(library(rgdal))
suppressMessages(library(spatstat))
```

## Dataset load

The dataset is loaded by a single call to an included utility function, see the code block below.

```{r}
source("R/ausplots.R")
load(ausplots())
```

The loaded data is in the following form.
First, we include the plot by plot data in the `configurations` and `windows` objects. 
These are lists of `ppjsdm` configurations and windows, respectively.
Each entry corresponds to a forest plot, with names shown below.

```{r}
print(names(configurations))
```

The objects can be accessed as follows.

```{r}
plot(configurations$Dip)
print(windows$Dip)
```

We also include the full configuration and corresponding window in the respective `configuration` and `window` objects.

```{r, fig.height = 10, fig.width = 15}
plot(configuration)
```

## Example fit on full dataset

```{r}
load(ausplots(plots_to_consider = c("Frankland", "Collins", "Clare", "Sutton", "Giants"), # Consider only 5 plots so that fit is not excessively slow
              only_species_with_per_plot = 1)) # Force there to be at least 1 individual of each considered species on each plot
ntypes <- nlevels(configuration$types)
tm <- Sys.time()
fit_complete <- gibbsm(configuration,
                       window = window,
                       model = "square_exponential", # Short-range interaction
                       medium_range_model = "tanh", # Medium-range interaction
                       short_range = matrix(10, ntypes, ntypes), # Matrix of short-range interaction distances
                       medium_range = matrix(200, ntypes, ntypes), # Matrix of medium-range interaction distances
                       long_range = matrix(1000, ntypes, ntypes), # Matrix of long-range interaction distances
                       saturation = 10, # Saturation parameter
                       fitting_package = "glmnet", # Fitting package 
                       min_dummy = 1e4, # Force at least 1e4 dummy points per species
                       max_dummy = 1e4, # Force at maximum 1e4 dummy points per species
                       dummy_distribution = "binomial") # Distribution of dummy points
print(Sys.time() - tm)
print(fit_complete$coefficients$alpha)
print(fit_complete$coefficients$gamma)
print(summary(fit_complete))
```

## More in-depth exploration of a single plot

We explore here a single plot which has the second largest number of species and third largest number of individuals.

```{r}
load(ausplots(plot_minimum_abundance = 10, overall_minimum_abundance = 1))
Bruxner <- configurations$Bruxner
Bruxner_window <- windows$Bruxner
plot(Bruxner)
```

And let's fit the model.

```{r, fig.height = 10, fig.width = 15}
ntypes <- nlevels(Bruxner$types)
tm <- Sys.time()
fit <- gibbsm(Bruxner,
              window = Bruxner_window,
              model = "square_exponential", # Short-range interaction
              medium_range_model = "tanh", # Medium-range interaction
              short_range = matrix(5, ntypes, ntypes), # Matrix of short-range interaction distances
              medium_range = matrix(20, ntypes, ntypes), # Matrix of medium-range interaction distances
              long_range = matrix(40, ntypes, ntypes), # Matrix of long-range interaction distances
              saturation = 10, # Saturation parameter
              fitting_package = "glm", # Fitting package 
              min_dummy = 1e3, # Force at least 1e3 dummy points per species
              max_dummy = 1e3, # Force at maximum 1e3 dummy points per species
              nthreads = 4, # Number of threads to use
              dummy_distribution = "stratified") # Distribution of dummy points
print(Sys.time() - tm)
summ <- summary(fit)
print(summ)
```

The model is also able to account for the trees' diameters, see code below.
In this case, the distances matrices are measured as multiples of the trees' dbhs.
We do not model any medium-range interactions to also illustrate how that would work.

```{r, fig.height = 10, fig.width = 15}
load(ausplots(use_marks = TRUE, plot_minimum_abundance = 10, overall_minimum_abundance = 1))
Bruxner <- configurations$Bruxner
Bruxner_window <- windows$Bruxner
plot(Bruxner)
ntypes <- nlevels(Bruxner$types)
tm <- Sys.time()
fit <- gibbsm(Bruxner,
              window = Bruxner_window,
              model = "square_exponential", # Short-range interaction
              short_range = matrix(50, ntypes, ntypes), # Matrix of short-range interaction ratios
              saturation = 10, # Saturation parameter
              fitting_package = "glmnet", # Fitting package 
              min_dummy = 1e3, # Force at least 1e3 dummy points per species
              max_dummy = 1e3, # Force at maximum 1e3 dummy points per species
              nthreads = 4, # Number of threads to use
              dummy_distribution = "stratified") # Distribution of dummy points
print(Sys.time() - tm)
summ <- summary(fit)
print(summ)
```

# Subset

Let us restrict our attention to the plots on the bottom-right.

```{r, fig.height = 10, fig.width = 15}
load(ausplots())
subs <- ppjsdm::Configuration(x = configuration$x[configuration$y < 3e3],
                              y = configuration$y[configuration$y < 3e3],
                              types = droplevels(configuration$types[configuration$y < 3e3]),
                              marks = configuration$marks[configuration$y < 3e3])
plot_indices <- sapply(window$y_ranges, function(yr) yr[2]) < 3e3
win <- ppjsdm::Rectangle_window_union(window$x_ranges[plot_indices], window$y_ranges[plot_indices])
print(win)
plot(subs)
```

```{r}
ntypes <- nlevels(subs$types)
tm <- Sys.time()
fit_complete <- ppjsdm::gibbsm(subs,
                               window = win,
                               model = "square_exponential", # Short-range interaction
                               medium_range_model = "tanh", # Medium-range interaction
                               short_range = matrix(10, ntypes, ntypes), # Matrix of short-range interaction distances
                               medium_range = matrix(200, ntypes, ntypes), # Matrix of medium-range interaction distances
                               long_range = matrix(1000, ntypes, ntypes), # Matrix of long-range interaction distances
                               saturation = 10, # Saturation parameter
                               fitting_package = "glmnet", # Fitting package 
                               min_dummy = 1e3, # Force at least 1e4 dummy points per species
                               max_dummy = 1e3, # Force at maximum 1e4 dummy points per species
                               dummy_distribution = "binomial", # Distribution of dummy points
                               debug = TRUE, # Add debugging info
                               nthreads = 4) # Number of threads to use
Sys.time() - tm
summary(fit_complete)
```

# Fit on one plot, predict on other

```{r}
fitting_plot <- "Mackenzie"
fitting_configuration <- configurations[[fitting_plot]]

prediction_plot <- "BenRidge"
prediction_configuration <- configurations[[prediction_plot]]

species <- union(levels(fitting_configuration$types), levels(prediction_configuration$types))

fitting_abundances <- sapply(species, function(t) sum(fitting_configuration$types == t))
prediction_abundances <- sapply(species, function(t) sum(prediction_configuration$types == t))
abundances <- setNames(sapply(species, function(sp) {
  fitting_abundances[sp] + prediction_abundances[sp]
}), nm = union(names(fitting_abundances), names(prediction_abundances)))

min_total <- 30
min_per_plot <- 10
new_names <- names(abundances)
new_names[abundances[new_names] < min_total | 
            fitting_abundances[new_names] < min_per_plot | 
            prediction_abundances[new_names] < min_per_plot] <- "Other species"
names(new_names) <- names(abundances)

levels(fitting_configuration$types) <- new_names[levels(fitting_configuration$types)]
levels(prediction_configuration$types) <- new_names[levels(prediction_configuration$types)]

plot(fitting_configuration)
plot(prediction_configuration)

ntypes <- nlevels(fitting_configuration$types)
tm <- Sys.time()
fit <- ppjsdm::gibbsm(fitting_configuration,
                      window = windows[[fitting_plot]],
                      model = "square_exponential", # Short-range interaction
                      medium_range_model = "tanh", # Medium-range interaction
                      short_range = matrix(10, ntypes, ntypes), # Matrix of short-range interaction distances
                      medium_range = matrix(20, ntypes, ntypes), # Matrix of medium-range interaction distances
                      long_range = matrix(50, ntypes, ntypes), # Matrix of long-range interaction distances
                      saturation = 10, # Saturation parameter
                      fitting_package = "glm", # Fitting package 
                      min_dummy = 1e4, # Force at least 1e4 dummy points per species
                      max_dummy = 1e4, # Force at maximum 1e4 dummy points per species
                      dummy_distribution = "stratified", # Distribution of dummy points
                      debug = TRUE, # Add debugging info
                      nthreads = 4) # Number of threads to use
Sys.time() - tm
summary(fit)

print(fit$coefficients$alpha)
print(fit$coefficients$gamma)
```

```{r}
sp <- levels(fitting_configuration$types)[1]
print(sp)
sp_index <- which(names(coef(fit)$beta0) == sp)
only_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types == sp], 
                                      y = prediction_configuration$x[prediction_configuration$types == sp],
                                      types = prediction_configuration$types[prediction_configuration$types == sp])
everything_except_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types != sp], 
                                      y = prediction_configuration$x[prediction_configuration$types != sp],
                                      types = prediction_configuration$types[prediction_configuration$types != sp])

sample <- ppjsdm::rgibbs(fit,
                         window = windows[[prediction_plot]],
                         steps = 1e3, # Number of steps in the Metropolis-Hastings algorithm
                         starting_configuration = only_species, # Starting configuration in the simulation
                         only_simulate_these_types = sp_index, # Which species to simulate
                         conditional_configuration = everything_except_species) # Conditional on these individuals
true_vs_sample <- ppjsdm::Configuration(x = c(only_species$x, sample$x),
                                        y = c(only_species$y, sample$y),
                                        types = c(rep("true", length(only_species$x)), 
                                                  rep("simulated", length(sample$x))))
plot(true_vs_sample)
```

```{r}
nsim <- 50
sp <- levels(fitting_configuration$types)[1]
sp_index <- which(names(coef(fit)$beta0) == sp)
only_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types == sp], 
                                      y = prediction_configuration$x[prediction_configuration$types == sp],
                                      types = prediction_configuration$types[prediction_configuration$types == sp])
everything_except_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types != sp], 
                                                   y = prediction_configuration$x[prediction_configuration$types != sp],
                                                   types = prediction_configuration$types[prediction_configuration$types != sp])

samples <- lapply(seq_len(nsim), function(i) {
  ppjsdm::rgibbs(fit,
                 window = windows[[prediction_plot]],
                 steps = 1e3,
                 starting_configuration = Configuration(),
                 only_simulate_these_types = sp_index,
                 conditional_configuration = everything_except_species)
})

samples <- lapply(samples, function(x) ppp(x = x$x, y = x$y, window = owin(c(0, 100), c(0, 100))))

only_species_ppp <- ppp(x = only_species$y[only_species$types == sp], 
                        y = only_species$x[only_species$types == sp],
                        window = owin(c(0, 100), c(0, 100)))
env <- envelope(only_species_ppp, fun = Linhom, nsim = length(samples), 
                normpower = 2, leaveoneout = FALSE, simulate = samples, verbose = FALSE)
plot(env)
abline(a = 0, b = 1, col = "blue")
```

```{r}
intensities <- lapply(samples, function(sample) density(sample))
conditional_intensity <- Reduce("+", intensities) / length(intensities)
plot(conditional_intensity)
points(only_species_ppp)
auc(only_species_ppp, conditional_intensity)

intensity_at_points <- as.function(conditional_intensity)(only_species_ppp$x, only_species_ppp$y)
residual <- density(only_species_ppp, weights = 1 / intensity_at_points)
range(residual)
plot(residual)
hist(residual)
```