---
title: "Ausplots"
output:
  pdf_document:
  latex_engine: xelatex
vignette: >
  %\VignetteIndexEntry{ausplots}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
                                                  "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = !is_check,
  purl = !is_check,
  tidy.opts = list(width.cutoff = 80), 
  tidy = TRUE
)
rm(list = ls())

set.seed(1)
```

In this vignette, we explore show how to fit our point process model to the TERN Ausplots dataset.
We begin by installing the `ppjsdm` package which implements the saturated pairwise interaction Gibbs point process.
We also load the `rgdal` library for its coordinate systems implementation.

```{r setup}
need_ppjsdm <- !("ppjsdm" %in% installed.packages()[, "Package"])
if(need_ppjsdm) {
  library(devtools)
  devtools::install_github("iflint1/ppjsdm", 
                           upgrade = "never",
                           quiet = TRUE)
}

suppressMessages(library(ggplot2))
suppressMessages(library(ppjsdm))
suppressMessages(library(rgdal))
suppressMessages(library(spatstat))
```

## Dataset load

The dataset is loaded by a single call to an included utility function, see the code block below.

```{r}
source("R/ausplots.R")
load(ausplots())
```

The loaded data is in the following form.
First, we include the plot by plot data in the `configurations` and `windows` objects. 
These are lists of `ppjsdm` configurations and windows, respectively.
Each entry corresponds to a forest plot, with names shown below.

```{r}
print(names(configurations))
```

The objects can be accessed as follows.

```{r}
plot(configurations$Dip)
print(windows$Dip)
```

We also include the full configuration and corresponding window in the respective `configuration` and `window` objects.

```{r, fig.height = 10, fig.width = 15}
plot(configuration)
```

## Example fit on multiple plots dataset

We load the dataset on a few target plots from the Victorian Highlands.

```{r}
# All Vic plots: "ANU101", "Ada Tree", "Weeaproinah", "ANU363", "ANU589", "Turtons", "Lardner", "HardyCreek"
load(ausplots(plots_to_consider = c("ANU101", "Ada Tree", "ANU363", "ANU589", "HardyCreek"),
              plot_minimum_abundance = 1)) # Only need one individual of the species on any of the plots for it to be considered

plot(configuration)
plot(configurations[[1]])
plot(configurations[[2]])
plot(configurations[[3]])
plot(configurations[[4]])
plot(configurations[[5]])
```

Each of these plots is $100\,\mathrm m\times 100\,\mathrm m$ large.
In our modelling, we expect individuals in plots located further than a few kilometers from one another do not interact much with one another.

```{r}
short <- 10 # Short-range distances
medium <- 200 # Medium-range distances, larger than the plot size
long <- 1000 # Long-range distances, chosen to forbid the plots located far awat from each other from "interacting" much
```

We are now in a position to run a first version of the fit.

```{r}
ntypes <- nlevels(configuration$types)
tm <- Sys.time()
fit <- gibbsm(configuration,
              window = window,
              model = "square_exponential", # Short-range interaction
              medium_range_model = "tanh", # Medium-range interaction
              short_range = matrix(short, ntypes, ntypes), # Matrix of short-range interaction distances
              medium_range = matrix(medium, ntypes, ntypes), # Matrix of medium-range interaction distances
              long_range = matrix(long, ntypes, ntypes), # Matrix of long-range interaction distances
              saturation = 4, # Saturation parameter
              fitting_package = "glm", # Fitting package 
              min_dummy = 1e5, # Force at least this many dummy points per species
              max_dummy = 1e5, # Force at maximum this many dummy points per species
              nthreads = 4, # Number of CPU cores to use
              dummy_distribution = "binomial") # Distribution of dummy points
print(Sys.time() - tm)
print(fit$coefficients$alpha)
print(fit$coefficients$gamma)
print(summary(fit))
```

We find that there are positive associations within each of the species, more so at the short range.
Eucalyptus regnans is an exception here, exhibiting strong negative intra-species associations at a short range.
Negative associations (indicating competition) are instead found to be the norm in inter-species interactions.
One can plot the corresponding Papangelou conditional intensity on some of the plots.

```{r, fig.height = 5, fig.width = 8}
sp <- "Eucalyptus regnans"
plot_index <- 1
sp_index <- which(levels(configurations[[plot_index]]$types) == sp)
prediction_configuration <- configurations[[plot_index]]

others <- ppjsdm::Configuration(x = prediction_configuration$x,
                                y = prediction_configuration$y,
                                types = prediction_configuration$types)

plot_papangelou(fit,
                window = windows[[plot_index]],
                configuration = others,
                type = sp_index,
                use_log = TRUE,
                grid_steps = c(500, 500))
```

```{r, fig.height = 5, fig.width = 8}
sp <- "Eucalyptus regnans"
plot_index <- 3
sp_index <- which(levels(configurations[[plot_index]]$types) == sp)
prediction_configuration <- configurations[[plot_index]]

others <- ppjsdm::Configuration(x = prediction_configuration$x[prediction_configuration$types != sp],
                                y = prediction_configuration$y[prediction_configuration$types != sp],
                                types = prediction_configuration$types[prediction_configuration$types != sp])
plot_papangelou(fit,
                window = windows[[plot_index]],
                configuration = others,
                type = sp_index,
                use_log = TRUE,
                grid_steps = c(500, 500)) + 
  geom_point(data = data.frame(x = prediction_configuration$x[prediction_configuration$types == sp],
                               y = prediction_configuration$y[prediction_configuration$types == sp]), 
             aes(x = x, y = y))
```

In order to get a better idea of how the model is performing, let us have a look at its predictions.
Let us look at other plots in Victoria, containing a few of the same species.

```{r}
# All Vic plots: "ANU101", "Ada Tree", "Weeaproinah", "ANU363", "ANU589", "Turtons", "Lardner", "HardyCreek"
load(ausplots(plots_to_consider = c("Weeaproinah", "Turtons", "Lardner"),
              plot_minimum_abundance = 1))

plot(configuration)
plot(configurations[[1]])
plot(configurations[[2]])
plot(configurations[[3]])
```

We see that one of the species (Pomaderris aspera) from the previous analysis is missing.
There are other ways to deal with this problem (e.g., deleting the rows and columns in the matrices corresponding to that species in the fitted parameters) but one easy way to proceed is to do the initial fit by binning the species together with other rare species.
Here is how you would do this.

```{r}
load(ausplots(plots_to_consider = c("ANU101", "Ada Tree", "ANU363", "ANU589", "HardyCreek"),
              plot_minimum_abundance = 1))

# Get rid of Pomaderris aspera, and bin it together with other rare species
new_types <- levels(configuration$types)
new_types[new_types == "Pomaderris aspera"] <- "Rare species"
levels(configuration$types) <- new_types

# Code below is exactly the same as the previous one
short <- 10 # Short-range distances
medium <- 200 # Medium-range distances, larger than the plot size
long <- 1000 # Long-range distances, chosen to forbid the plots located far awat from each other from "interacting" much

ntypes <- nlevels(configuration$types)
tm <- Sys.time()
fit <- gibbsm(configuration,
              window = window,
              model = "square_exponential", # Short-range interaction
              medium_range_model = "tanh", # Medium-range interaction
              short_range = matrix(short, ntypes, ntypes), # Matrix of short-range interaction distances
              medium_range = matrix(medium, ntypes, ntypes), # Matrix of medium-range interaction distances
              long_range = matrix(long, ntypes, ntypes), # Matrix of long-range interaction distances
              saturation = 4, # Saturation parameter
              fitting_package = "glm", # Fitting package 
              min_dummy = 1e5, # Force at least this many dummy points per species
              max_dummy = 1e5, # Force at maximum this many dummy points per species
              nthreads = 4, # Number of CPU cores to use
              dummy_distribution = "binomial") # Distribution of dummy points
print(Sys.time() - tm)
print(fit$coefficients$alpha)
print(fit$coefficients$gamma)
print(summary(fit))
```

We load once again the plots on which we wish to do prediction, and we bin the species so that the species names are the same.

```{r}
load(ausplots(plots_to_consider = c("Weeaproinah", "Turtons", "Lardner"),
              plot_minimum_abundance = 1))

new_types <- levels(configuration$types)
new_types[!(new_types %in% colnames(fit$coefficients$alpha))] <- "Rare species"
levels(configuration$types) <- new_types

for(i in seq_len(length(configurations))) {
  new_types <- levels(configurations[[i]]$types)
  new_types[!(new_types %in% colnames(fit$coefficients$alpha))] <- "Rare species"
  levels(configurations[[i]]$types) <- new_types
}

plot(configuration)
plot(configurations[[1]])
plot(configurations[[2]])
plot(configurations[[3]])
```

The `ppjsdm` package is able to simulate one species conditional on the others, conditional on the fitted model.
To begin assessing the model performance, let us draw one sample of Eucalyptus regnans conditional on other species, and see how it compares to the actual distribution.

```{r}
plot_index <- 3
sp <- "Acacia melanoxylon"
sp_index <- which(names(coef(fit)$beta0) == sp)
prediction_configuration <- configurations[[plot_index]]
only_species <- ppjsdm::Configuration(x = prediction_configuration$x[prediction_configuration$types == sp], 
                                      y = prediction_configuration$y[prediction_configuration$types == sp],
                                      types = prediction_configuration$types[prediction_configuration$types == sp])
everything_except_species <- ppjsdm::Configuration(x = prediction_configuration$x[prediction_configuration$types != sp], 
                                                   y = prediction_configuration$y[prediction_configuration$types != sp],
                                                   types = prediction_configuration$types[prediction_configuration$types != sp])

sample <- ppjsdm::rgibbs(fit,
                         window = windows[[plot_index]], # Where we want to simulate
                         steps = 1e4, # Number of steps in the Metropolis-Hastings algorithm
                         starting_configuration = only_species, # Starting configuration in the simulation
                         only_simulate_these_types = sp_index, # Which species to simulate
                         conditional_configuration = everything_except_species) # Conditional on these individuals
true_vs_sample <- ppjsdm::Configuration(x = c(only_species$x, sample$x),
                                        y = c(only_species$y, sample$y),
                                        types = c(rep("true", length(only_species$x)), 
                                                  rep("simulated", length(sample$x))))
plot(true_vs_sample)
```

## More in-depth exploration of a single plot

We explore here a single plot which has the second largest number of species and third largest number of individuals.

```{r}
load(ausplots(plot_minimum_abundance = 10, overall_minimum_abundance = 1))
Bruxner <- configurations$Bruxner
Bruxner_window <- windows$Bruxner
plot(Bruxner)
```

And let's fit the model.

```{r, fig.height = 10, fig.width = 15}
ntypes <- nlevels(Bruxner$types)
tm <- Sys.time()
fit <- gibbsm(Bruxner,
              window = Bruxner_window,
              model = "square_exponential", # Short-range interaction
              medium_range_model = "tanh", # Medium-range interaction
              short_range = matrix(5, ntypes, ntypes), # Matrix of short-range interaction distances
              medium_range = matrix(20, ntypes, ntypes), # Matrix of medium-range interaction distances
              long_range = matrix(40, ntypes, ntypes), # Matrix of long-range interaction distances
              saturation = 10, # Saturation parameter
              fitting_package = "glm", # Fitting package 
              min_dummy = 1e3, # Force at least 1e3 dummy points per species
              max_dummy = 1e3, # Force at maximum 1e3 dummy points per species
              nthreads = 4, # Number of threads to use
              dummy_distribution = "stratified") # Distribution of dummy points
print(Sys.time() - tm)
summ <- summary(fit)
print(summ)
```

The model is also able to account for the trees' diameters, see code below.
In this case, the distances matrices are measured as multiples of the trees' dbhs.
We do not model any medium-range interactions

```{r, fig.height = 10, fig.width = 15}
load(ausplots(use_marks = TRUE, plot_minimum_abundance = 10, overall_minimum_abundance = 1))
Bruxner <- configurations$Bruxner
Bruxner_window <- windows$Bruxner
plot(Bruxner)
ntypes <- nlevels(Bruxner$types)
tm <- Sys.time()
fit <- gibbsm(Bruxner,
              window = Bruxner_window,
              model = "square_exponential", # Short-range interaction
              short_range = matrix(50, ntypes, ntypes), # Matrix of short-range interaction ratios
              saturation = 10, # Saturation parameter
              fitting_package = "glmnet", # Fitting package 
              min_dummy = 1e3, # Force at least 1e3 dummy points per species
              max_dummy = 1e3, # Force at maximum 1e3 dummy points per species
              nthreads = 4, # Number of threads to use
              dummy_distribution = "stratified") # Distribution of dummy points
print(Sys.time() - tm)
summ <- summary(fit)
print(summ)
```

# Subset

Let us restrict our attention to the plots on the bottom-right.

```{r, fig.height = 10, fig.width = 15}
load(ausplots())
subs <- ppjsdm::Configuration(x = configuration$x[configuration$y < 3e3],
                              y = configuration$y[configuration$y < 3e3],
                              types = droplevels(configuration$types[configuration$y < 3e3]),
                              marks = configuration$marks[configuration$y < 3e3])
plot_indices <- sapply(window$y_ranges, function(yr) yr[2]) < 3e3
win <- ppjsdm::Rectangle_window_union(window$x_ranges[plot_indices], window$y_ranges[plot_indices])
print(win)
plot(subs)
```

```{r}
ntypes <- nlevels(subs$types)
tm <- Sys.time()
fit_complete <- ppjsdm::gibbsm(subs,
                               window = win,
                               model = "square_exponential", # Short-range interaction
                               medium_range_model = "tanh", # Medium-range interaction
                               short_range = matrix(10, ntypes, ntypes), # Matrix of short-range interaction distances
                               medium_range = matrix(200, ntypes, ntypes), # Matrix of medium-range interaction distances
                               long_range = matrix(1000, ntypes, ntypes), # Matrix of long-range interaction distances
                               saturation = 10, # Saturation parameter
                               fitting_package = "glmnet", # Fitting package 
                               min_dummy = 1e3, # Force at least 1e4 dummy points per species
                               max_dummy = 1e3, # Force at maximum 1e4 dummy points per species
                               dummy_distribution = "binomial", # Distribution of dummy points
                               debug = TRUE, # Add debugging info
                               nthreads = 4) # Number of threads to use
Sys.time() - tm
summary(fit_complete)
```

# Fit on one plot, predict on other

```{r}
fitting_plot <- "Mackenzie"
fitting_configuration <- configurations[[fitting_plot]]

prediction_plot <- "BenRidge"
prediction_configuration <- configurations[[prediction_plot]]

species <- union(levels(fitting_configuration$types), levels(prediction_configuration$types))

fitting_abundances <- sapply(species, function(t) sum(fitting_configuration$types == t))
prediction_abundances <- sapply(species, function(t) sum(prediction_configuration$types == t))
abundances <- setNames(sapply(species, function(sp) {
  fitting_abundances[sp] + prediction_abundances[sp]
}), nm = union(names(fitting_abundances), names(prediction_abundances)))

min_total <- 30
min_per_plot <- 10
new_names <- names(abundances)
new_names[abundances[new_names] < min_total | 
            fitting_abundances[new_names] < min_per_plot | 
            prediction_abundances[new_names] < min_per_plot] <- "Other species"
names(new_names) <- names(abundances)

levels(fitting_configuration$types) <- new_names[levels(fitting_configuration$types)]
levels(prediction_configuration$types) <- new_names[levels(prediction_configuration$types)]

plot(fitting_configuration)
plot(prediction_configuration)

ntypes <- nlevels(fitting_configuration$types)
tm <- Sys.time()
fit <- ppjsdm::gibbsm(fitting_configuration,
                      window = windows[[fitting_plot]],
                      model = "square_exponential", # Short-range interaction
                      medium_range_model = "tanh", # Medium-range interaction
                      short_range = matrix(10, ntypes, ntypes), # Matrix of short-range interaction distances
                      medium_range = matrix(20, ntypes, ntypes), # Matrix of medium-range interaction distances
                      long_range = matrix(50, ntypes, ntypes), # Matrix of long-range interaction distances
                      saturation = 10, # Saturation parameter
                      fitting_package = "glm", # Fitting package 
                      min_dummy = 1e4, # Force at least 1e4 dummy points per species
                      max_dummy = 1e4, # Force at maximum 1e4 dummy points per species
                      dummy_distribution = "stratified", # Distribution of dummy points
                      debug = TRUE, # Add debugging info
                      nthreads = 4) # Number of threads to use
Sys.time() - tm
summary(fit)

print(fit$coefficients$alpha)
print(fit$coefficients$gamma)
```

```{r}
sp <- levels(fitting_configuration$types)[1]
print(sp)
sp_index <- which(names(coef(fit)$beta0) == sp)
only_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types == sp], 
                                      y = prediction_configuration$x[prediction_configuration$types == sp],
                                      types = prediction_configuration$types[prediction_configuration$types == sp])
everything_except_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types != sp], 
                                      y = prediction_configuration$x[prediction_configuration$types != sp],
                                      types = prediction_configuration$types[prediction_configuration$types != sp])

sample <- ppjsdm::rgibbs(fit,
                         window = windows[[prediction_plot]],
                         steps = 1e3, # Number of steps in the Metropolis-Hastings algorithm
                         starting_configuration = only_species, # Starting configuration in the simulation
                         only_simulate_these_types = sp_index, # Which species to simulate
                         conditional_configuration = everything_except_species) # Conditional on these individuals
true_vs_sample <- ppjsdm::Configuration(x = c(only_species$x, sample$x),
                                        y = c(only_species$y, sample$y),
                                        types = c(rep("true", length(only_species$x)), 
                                                  rep("simulated", length(sample$x))))
plot(true_vs_sample)
```

```{r}
nsim <- 50
sp <- levels(fitting_configuration$types)[1]
sp_index <- which(names(coef(fit)$beta0) == sp)
only_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types == sp], 
                                      y = prediction_configuration$x[prediction_configuration$types == sp],
                                      types = prediction_configuration$types[prediction_configuration$types == sp])
everything_except_species <- ppjsdm::Configuration(x = prediction_configuration$y[prediction_configuration$types != sp], 
                                                   y = prediction_configuration$x[prediction_configuration$types != sp],
                                                   types = prediction_configuration$types[prediction_configuration$types != sp])

samples <- lapply(seq_len(nsim), function(i) {
  ppjsdm::rgibbs(fit,
                 window = windows[[prediction_plot]],
                 steps = 1e3,
                 starting_configuration = Configuration(),
                 only_simulate_these_types = sp_index,
                 conditional_configuration = everything_except_species)
})

samples <- lapply(samples, function(x) ppp(x = x$x, y = x$y, window = owin(c(0, 100), c(0, 100))))

only_species_ppp <- ppp(x = only_species$y[only_species$types == sp], 
                        y = only_species$x[only_species$types == sp],
                        window = owin(c(0, 100), c(0, 100)))
env <- envelope(only_species_ppp, fun = Linhom, nsim = length(samples), 
                normpower = 2, leaveoneout = FALSE, simulate = samples, verbose = FALSE)
plot(env)
abline(a = 0, b = 1, col = "blue")
```

```{r}
intensities <- lapply(samples, function(sample) density(sample))
conditional_intensity <- Reduce("+", intensities) / length(intensities)
plot(conditional_intensity)
points(only_species_ppp)
auc(only_species_ppp, conditional_intensity)

intensity_at_points <- as.function(conditional_intensity)(only_species_ppp$x, only_species_ppp$y)
residual <- density(only_species_ppp, weights = 1 / intensity_at_points)
range(residual)
plot(residual)
hist(residual)
```

# Eucalyptus obliqua

```{r}
load(ausplots(plots_to_consider = c("Newline", "WaratahMix", "WogWay", "Goodenia", "Candelo"),
              plot_minimum_abundance = 1))

# Get rid of of everything except Eucalyptus obliqua
new_types <- levels(configuration$types)
new_types[new_types != "Eucalyptus obliqua"] <- "Other species"
levels(configuration$types) <- new_types

ntypes <- nlevels(configuration$types)
tm <- Sys.time()
fit <- ppjsdm::gibbsm(configuration,
                      window = window,
                      model = "square_exponential", # Short-range interaction
                      medium_range_model = "tanh", # Medium-range interaction
                      short_range = matrix(10, ntypes, ntypes), # Matrix of short-range interaction distances
                      medium_range = matrix(15, ntypes, ntypes), # Matrix of medium-range interaction distances
                      long_range = matrix(50, ntypes, ntypes), # Matrix of long-range interaction distances
                      saturation = 4, # Saturation parameter
                      fitting_package = "glmnet", # Fitting package 
                      min_dummy = 1e5, # Force at least this many dummy points per species
                      max_dummy = 1e5, # Force at maximum this many dummy points per species
                      dummy_distribution = "binomial", # Distribution of dummy points
                      nthreads = 4) # Number of threads to use
Sys.time() - tm
fit$coefficients$alpha
fit$coefficients$gamma
summary(fit)
```

```{r}
load(ausplots(plots_to_consider = c("Flowerdale", "Dip", "Bird"),
              plot_minimum_abundance = 1))

# Get rid of of everything except Eucalyptus obliqua
new_types <- levels(configuration$types)
new_types[new_types != "Eucalyptus obliqua"] <- "Other species"
levels(configuration$types) <- new_types

for(i in seq_len(length(configurations))) {
  new_types <- levels(configurations[[i]]$types)
  new_types[new_types != "Eucalyptus obliqua"] <- "Other species"
  levels(configurations[[i]]$types) <- new_types
}

plot_index <- 2
sp <- "Eucalyptus obliqua"
sp_index <- which(names(coef(fit)$beta0) == sp)
prediction_configuration <- configurations[[plot_index]]
only_species <- ppjsdm::Configuration(x = prediction_configuration$x[prediction_configuration$types == sp], 
                                      y = prediction_configuration$y[prediction_configuration$types == sp],
                                      types = prediction_configuration$types[prediction_configuration$types == sp])
everything_except_species <- ppjsdm::Configuration(x = prediction_configuration$x[prediction_configuration$types != sp], 
                                                   y = prediction_configuration$y[prediction_configuration$types != sp],
                                                   types = prediction_configuration$types[prediction_configuration$types != sp])

samples <- ppjsdm::rgibbs(fit,
                          nsim = 50,
                          window = windows[[plot_index]], # Where we want to simulate
                          steps = 1e3, # Number of steps in the Metropolis-Hastings algorithm
                          starting_configuration = only_species, # Starting configuration in the simulation
                          only_simulate_these_types = sp_index, # Which species to simulate
                          conditional_configuration = everything_except_species) # Conditional on these individuals

ppp_samples <- lapply(samples, function(sample) ppp(x = sample$x,
                                                    y = sample$y,
                                                    window = owin(c(0, 100), c(0, 100))))
only_species_ppp <- ppp(x = only_species$x,
                        y = only_species$y,
                        window = owin(c(0, 100), c(0, 100)))

intensities <- lapply(ppp_samples, function(sample) density(sample))
conditional_intensity <- Reduce("+", intensities) / length(intensities)
plot(conditional_intensity)
points(only_species_ppp)
auc(only_species_ppp, conditional_intensity)

intensity_at_points <- as.function(conditional_intensity)(only_species_ppp$x, only_species_ppp$y)
residual <- density(only_species_ppp, weights = 1 / intensity_at_points)
range(residual)
plot(residual)
hist(residual)

true_vs_sample <- ppjsdm::Configuration(x = c(only_species$x, samples[[1]]$x),
                                        y = c(only_species$y, samples[[1]]$y),
                                        types = c(rep("true", length(only_species$x)), 
                                                  rep("simulated", length(sample$x))))
plot(true_vs_sample)
```

# Generate some pretty plots for presentation

```{r}
source("R/ausplots.R")
load(ausplots(plot_minimum_abundance = 1, overall_minimum_abundance = 1))

plot(configurations$Dombakup)
plot(configurations$ANU589)
```

